<html>
    <head>

    </head>
    <body>
        <script>

            // 変数定義
            let 部品 = {
                "1": { 品名: 'x' }
                , "2": { 品名: 'A' }
                , "3": { 品名: 'B' }
                , "4": { 品名: 'C' }
                , "5": { 品名: 'A1' }
                , "6": { 品名: 'A2' }
                , "7": { 品名: 'A3' }
                , "8": { 品名: 'A4' }
                , "9": { 品名: 'B1' }
                , "10": { 品名: 'A1A' }
                , "11": { 品名: 'A2A' }
                , "12": { 品名: 'A2B' }
                , "13": { 品名: 'A3A' }
                , "14": { 品名: 'A3B' }
                , "15": { 品名: 'A4A' }
                , "16": { 品名: 'A4B' }
                , "17": { 品名: 'AA' }
                , "18": { 品名: 'AB' }
            };
            let 親子関係 = [
                [0, 1]

                , [1, 2]
                , [1, 3]
                , [1, 4]

                , [2, 5]
                , [2, 6]
                , [2, 7]
                , [2, 8]

                , [3, 4]
                , [3, 9]

                , [5, 4]
                , [5, 10]
                , [6, 11]
                , [6, 12]
                , [7, 13]
                , [7, 14]
                , [8, 15]
                , [8, 16]

                , [10, 4]
                , [10, 17]
                , [11, 17]
                , [12, 18]
                , [13, 17]
                , [14, 18]
                , [15, 17]
                , [16, 18]

                , [17, 18]
                , [18, 17]
                , [4, 4]
            ];
            let 階層 = [];



            // 標準処理関数
            function In(a, b) {
                for (let i = 0; i < b.length; ++i) {
                    if (a == b[i]) { return true; }
                }
                return false;
            }



            // 実子品番探索
            function find実子品番(品番) {
                // 循環参照対象品番は除く
                let 実子品番 = [];
                for (let i = 0; i < 親子関係.length; ++i) {
                    if (!部品[親子関係[i][1]].循環参照
                        && 親子関係[i][0] == 品番) {
                        実子品番.push(親子関係[i][1]);
                    }
                }
                return 実子品番;
            }



            // 階層設定
            function do階層設定(品番, 階層) {
                if (部品[品番].最上位階層 > 階層
                    || 部品[品番].最上位階層 == 0) {
                    部品[品番].最上位階層 = 階層;
                }
                if (部品[品番].最下位階層 < 階層) {
                    部品[品番].最下位階層 = 階層;
                }
            }



            // 品番階層振分け
            function do階層振分け(探索品番, 階層) {
                let 実子品番 = find実子品番(探索品番[探索品番.length - 1]);
                let wk品番, 品番経路;

                if (階層 == void 0) { 階層 = 0; }
                ++階層;
                for (let i = 0; i < 実子品番.length; ++i) {
                    do階層設定(実子品番[i], 階層);
                    品番経路 = 探索品番; // Deep Copy.
                    if (In(実子品番[i], 品番経路)) {
                        do {
                            wk品番 = 品番経路.pop();
                            部品[wk品番].循環参照 = true;
                            do階層設定(wk品番, 階層);
                        } while (wk品番 != 実子品番[i]);
                    }
                    else {
                        品番経路.push(実子品番[i]);
                        do階層振分け(品番経路, 階層);
                    }
                }

            }



            // 
            addEventListener('load', function () {

                // 新ツリー図用変数定義
                for (let 品番 in 部品) {
                    部品[品番].最上位階層 = 0;
                    部品[品番].最下位階層 = 0;

                    部品[品番].循環参照 = false;
                    部品[品番].階層 = {};
                }

                do階層振分け([0]);

                /*

                循環参照indexの作成
                循環参照をリングと見立てて、隣接するリングの検出
                親リング直営品か否か。

                */

                for (let 品番 in 部品) {
                    console.log(品番 + ":" + 部品[品番].最上位階層 + ":" + 部品[品番].最下位階層);
                }

            });

        </script>
    </body>
</html>
